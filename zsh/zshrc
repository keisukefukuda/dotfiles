# Lines configured by zsh-newuser-install
HISTFILE=~/.histfile
HISTSIZE=100000
SAVEHIST=100000

#hostname | egrep '^t2a' > /dev/null && fpath=($HOME/local/share/zsh/5.0.0/functions)


# Look for zsh fpath directories
if [ -d $HOME/local/share/zsh ]; then
  for d in $(find $HOME/local/share/zsh -type d -name "functions"); do
    fpath=($d ${fpath})
  done
fi

# for Emacs tramp
[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ ' && return

setopt append_history
setopt autocd
setopt share_history
setopt hist_ignore_dups
setopt NO_flow_control
setopt interactive_comments
setopt magic_equal_subst
setopt print_eightbit
setopt extended_glob
setopt shwordsplit
setopt autopushd pushdminus pushdsilent pushdtohome

unsetopt beep
bindkey -e

fignore=(.o .d .aux .log .toc)

# The following lines were added by compinstall
zstyle :compinstall filename '/home/kei/.zshrc'
zstyle ':completion:*' verbose yes
zstyle ':completion:*:descriptions' format '%B%d%b'
zstyle ':completion:*:messages' format '%d'
zstyle ':completion:*:warnings' format 'No matches for:%d'
zstyle ':completion:*' group-name ''

autoload -Uz zmv
alias zmv='noglob zmv -W'

autoload -Uz compinit
compinit -u

autoload -U colors && colors

autoload -Uz zmv
alias zmv='noglob zmv -W'

# aliases
# check if ls accept --color option
ls --color >/dev/null 2>&1
if [ "$?" -eq 0 ]; then
	alias ls='ls -FG --color'
else
	alias ls='ls -FG'
fi
alias ll='ls -laF'
alias la='ls -aG'
alias lv='lv -Ou8'
alias pelr='perl'
alias amke='make'
alias mkae='make'
alias mkdri='mkdir'
alias svnst='svn st'
alias sc='screen'
alias em='emacs -nw'
alias gt='gnome-terminal&'
alias Less="less"

#alias ga='git add'
#alias gp='git push'
#alias gl='git log'
alias gsu='git status'
#alias gd='git diff --color | less -R'
#alias gdc='git diff --cached'

export LANG=en_US.UTF-8
export LESSCHARSET=utf-8
export LC_CTYPE="en_US.UTF-8"

export PATH=$HOME/bin:$HOME/local/bin:/usr/local/bin:$HOME/local/cuda/bin:$PATH
if [ -d "$HOME/local" ]; then
	export LD_RUN_PATH=$LD_RUN_PATH:$HOME/local/lib
	export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$HOME/local/lib
	export MANPATH=$MANPATH:$HOME/local/share/man
fi

if [ -d /opt/local/bin ]; then
	export PATH=/opt/local/bin:$PATH
fi

if [ -d $HOME/.cask/bin ]; then
	export PATH="$HOME/.cask/bin:$PATH"
fi

# Python settings
export PYTHONIOENCODING='utf8'

export PATH=/usr/local/cuda/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH

export MANPATH=$MANPATH:$HOME/local/share/man

# pkgconfig
if [ -d $HOME/local/lib/pkgconfig ]; then
	export PKG_CONFIG_PATH=$HOME/local/lib/pkgconfig:$PKG_CONFIG
fi

# TeX Live
TEXLIVE_ROOT=/usr/local/texlive
if [ -d $TEXLIVE_ROOT ]; then
	  pdflatex=`find ${TEXLIVE_ROOT}/20*/bin -name "pdflatex" | sort -r | head -n 1`

	if [ -x "${pdflatex}" ]; then
		  # make sure that the latest TeXLive installation is used
	    export PATH=`dirname "${pdflatex}"`:$PATH
	fi
fi

export SVN_EDITOR=emacs
export PERL_BADLANG=0
export EDITOR=vi
export PAGER=less
export MAILCHECK=0

export HREF_DATADIR=$HOME/local/share/doc/href

#if which xset &>/dev/null; then xset b off >/dev/null 2>&1; fi

export GTK_IM_MODULE=ibus
export XMODIFIERS=@im=ibus
export QT_IM_MODULE=ibus

#----------------------------------------------------------------------------
# Prompt settings

export RPROMPT='[%~]'
# This zsh function is called whenever changing directories and
# shows the current git branch in the prompt

function dirlevel()
{
    if [ "$PWD" = "/" ]; then
        echo 0
        exit
    fi

    grep -o "/" <<<"$PWD" | wc -l
}

function readlink_f()
{
	# if readlink -f is available, use it. It not (on MacOS and other BSD systmes)
	# emulate the behavior using the vanilla readlink command.
	if uname -a | grep -q Linux; then
		 readlink -f $*
	else
	   # TODO
		 echo $*
	fi
}


function findup()
{
    local cur_dir trg_dir
    trg_dir="$1"
    if test -z "$trg_dir"; then exit 1; fi # if target dir is empty

    cur_dir=$PWD

    cnt=0
    while ! test -e "$cur_dir/$trg_dir"; do
        cur_dir=`readlink_f $cur_dir/..`
        #echo $cur_dir >&2

        if [[ ! -d "$cur_dir" ]]; then
            echo ""
            return
        fi

        if test "$cur_dir" = "/"; then
            exit 1
        fi
        cnt=`expr ${cnt} + 1`

        if [ ${cnt} -gt 10 ]; then
            echo ""
            return
        fi
    done
    
    echo $cur_dir/$trg_dir
}

function precmd()
{
    # Adjust this to your current preferred prompt
    PROMPT="%n@%{$terminfo[bold]%}%M%{$terminfo[sgr0]%}:%l"
    local _git _branch

    # This call requires the "findup" script from http://www.davidfaure.fr/scripts
    _git=`findup .git`

    if test -n "$_git"; then
        _branch=`sed -e 's,.*/,,' $_git/HEAD`
        PROMPT="$PROMPT %{$fg[yellow]%}[git:$_branch]%{$reset_color%}"
    fi

    # Alternative solution, from Mike Arthur: something like:
    # BRANCH_REFS=$(git symbolic-ref HEAD 2>/dev/null); PROMPT="$PROMPT (${BRANCH_REFS#refs/heads/})"

    # Add final character after the optional git branch (usually # or >)
    export PROMPT="%{$fg[green]%}$PROMPT%{$reset_color%}
 %(!.#.$) "
}

#----------------------------------------------------------
# mozc tools

if [ -d /usr/lib/mozc ]; then
    alias mozc-config="/usr/lib/mozc/mozc_tool -mode=config_dialog"
    alias mozc-dict="/usr/lib/mozc/mozc_tool --mode=dictionary_tool"
fi


#-----------------------------------------------------------
# utility commands
function update_haskell_packages() {
    cab sync
    outdated=$(cab outdated | awk '{print $1}')

    for pkg in $outdated; do
        cab delete -r $pkg
    done

    for pkg in $outdated; do
        cab install $pkg
    done
}

function mkdirx () {
    mkdir "$1" && cd "$1"
}


function bzhead() {
    fn="$1"
    shift
    bzcat $fn | head $*
}

function bztail() {
    fn="$1"
    shift
    bzcat $fn | tail $*
}

function today() {
     date +%Y%m%d
}

function now() { 
     date +%Y%m%d%H%M
}


#-----------------------------------------------------------
export GPG_AGENT_INFO_FILE=$HOME/.gpg-agent-info
if which gpg-agent; then
	gpg-agent --daemon --enable-ssh-support --write-env-file "${GPG_AGENT_INFO_FILE}"
fi

if [ -f "${GPG_AGENT_INFO_FILE}" ]; then
    . "${GPG_AGENT_INFO_FILE}"
    export GPG_AGENT_INFO
    export SSH_AUTH_SOCK
    export SSH_AGENT_PID
fi

export GPG_TTY=$(tty)

#-----------------------------------------------------------
# Read environment-dependent zshrc files
function load_if_present() {
    if [ -f "$1" ]; then
        source $1
    fi
}

load_if_present $HOME/.zsh.local
load_if_present $HOME/.zshrc.local

today () {
	date +%Y%m%d
}

### Added by the Heroku Toolbelt
if [[ -d "/usr/local/heroku/bin" ]] ; then
    export PATH="/usr/local/heroku/bin:$PATH"
fi
